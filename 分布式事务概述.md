本篇主要是分布式事务内容概要，主要讲述以下内容。关于其中各部分详细讲解请参见其他篇章。

- 什么是事务、事务和锁的关系
- 事务的传播机制
- 什么是分布式事务？为什么需要分布式事务？
- 分布式事务处理机制
- 分布式事务的实现
- 分布式事务的实现原理
- 开源实现

参考： http://opengroup.org >> Distributed Transaction Processing: The XA Specification。

# 事务和锁

事务和锁本身没什么好说的，事务4个特性：acid、原子性、一致性、隔离性、持久性。这个在mysql中我们已经详细说过，详细见[从关系说到MySQL底层原理](http://void-x1.github.io/mysql论道) 。核心其实就是原子性，隔离是为了保证原子性，一致性是原子性的结果，持久是事务的附属的一个谓语——必须要是对结果不可变的。

锁，是事务控制的一个工具，通过锁来实现隔离性。类似并发（并发的3要素：原子性、有序性、可见性）中使用锁对线程进行隔离一样，事务中可以使用锁进行隔离。
> 这里我们要说的一点是隔离性不一定要通过锁来控制，**类似MySQL中使用MVCC实现了多种隔离级别**[mysql必知必会](http://void-x1.github.io/mysql必知必会)。

在事务中，控制一致性除了隔离机制以外，还有“开始-savePoint-提交”机制 ，当事务中的某个阶段失败以后，将整个事务阶段性或者全部回滚，保证事务内数据的一致性。



#事务的传播机制
在并发中，隔离的是代码块，而**事务中需要隔离的通常是一个个完整的操作**，通常对应的是一个函数。同样，在一个操作中，可能有多个小的步骤，这些小的步骤封装在可能是一个本地函数，也可能是一个RPC远程调用中。

当在一个事务中，调用另一个步骤的时候，对与新的步骤的事务如何处理，可能有多种策略，在spring中定义了7种事务传播机制

- REQUIRED ：表示当前方法必须在一个事务内执行。
如果当前没有事务，则新开启一个事务。
如果当前存在事务，则沿用当前事务。
- REQUIRES_NEW ：表示当前方法必须在一个新的事务中执行。
如果当前存在事务，则挂起当前事务，开启新的事务。
执行完毕后再恢复原先的事务。
- NESTED：表示当前方法必须在一个嵌套事务中执行。
如果当前没有事务，则新开启一个事务。
如果当前存在事务，则在当前事务的基础上创建一个嵌套事务。
使用场景：需要对当前事务进行子事务的操作，如订单的部分退款操作。
- SUPPORTED：表示当前方法支持当前事务，但如果当前没有事务，则作为非事务性方法执行。
使用场景：当方法是否需要事务性执行取决于调用它的事务环境时。
- NOT_SUPPORTED：表示当前方法不需要在事务环境中执行，如果当前存在事务，则挂起当前事务。
使用场景：当方法不需要事务性支持时，避免不必要的性能开销。
- MANDATORY：表示当前方法必须在一个已存在的事务中执行，如果当前没有事务，则抛出异常。
使用场景：确保方法执行时一定处于事务环境中。
- NEVER：表示当前方法不应该在事务环境中执行，如果当前存在事务，则抛出异常。
使用场景：当方法执行时明确不需要事务支持时。

**这里需要补充的一点是REQUIRES\_NEW和NESTED的区别**

1. 事务的独立性。
REQUIRES\_NEW：这种机制要求当前方法必须在一个新的事务中执行。如果当前存在事务，则挂起当前事务（即暂停执行），并开启一个新的事务。新事务的执行不依赖于原有事务的提交或回滚，即它们是完全独立的。当新事务执行完毕后，再继续执行原有事务（如果之前被挂起的话）。
NESTED：如果当前存在事务，则在当前事务的基础上创建一个嵌套事务（子事务）。嵌套事务是外部事务（父事务）的一部分，它的执行受到外部事务的控制。如果外部事务提交，嵌套事务也会提交；如果外部事务回滚，嵌套事务也会回滚。但是，嵌套事务可以拥有自己的保存点（savepoint），这意味着在嵌套事务中发生异常时，可以选择回滚到保存点，而不是整个外部事务都回滚。
2. 异常处理。
REQUIRES_NEW：由于新事务与原有事务完全独立，因此原有事务中的异常不会影响到新事务的执行。即使原有事务因为异常而回滚，新事务仍然可以提交或回滚（取决于新事务内部的逻辑）。
NESTED：嵌套事务作为外部事务的一部分，其异常处理与外部事务紧密相关。如果嵌套事务中发生异常并被捕获，可以选择回滚到保存点，但这不会影响到外部事务的其他部分（除非外部事务本身也发生异常）。然而，如果外部事务因为异常而回滚，嵌套事务也会一并回滚。

# 分布式事务
在分布式系统种，调用关系，通常有集中

1. 分布式系统种有多个节点，多个节点操作共享资源，需要去保证ACID(一致性)，这种情况和并发是类似的。和多线程操作共享变量类似。
2. 分布式系统A 调用系统 B。这种情况，比较复杂，面临的问题通常有下游分布式服务的网络问题、BUG等异常情况。

解决1中的情况，可以使用分布式锁。
解决2的情况需要使用到分布式事务处理机制。

## 分布式事务处理理论基础
CAP定理：分布式系统无法同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition Tolerance）三个指标，最多只能满足其中两个。

BASE理论：是对CAP定理的一种解决思路，包含基本可用（Basically Available）、软状态（Soft State）和最终一致性（Eventually Consistent）三个思想。


## 分布式事务模型
- X/Open DTP模型
- 两阶段提交协议（2PC）
- 三阶段提交协议（3PC）

# 分布式事务处理机制 #
分布式事务处理有多种实现机制，通常有如下几种

- XA模式（eXtended Architecture 扩展架构）
- AT模式（Automatic Transaction），由阿里的Seata提供
- TCC模式（Try-Confirm-Cancel）
- SAGA模式：Sequentially Consistent Autonomous Global Transactions（顺序一致性的自主全局事务）

# 分布式事务实现
**分布式锁**

- REDIS SNX

**分布式事务**


- SEATA ：提供了AT、TCC、SAGA和XA等多种事务模式
- ByteTCC：遵循TCC模式，确保事务的原子性和一致性。
在尝试阶段预留必要的资源，在确认阶段提交事务，在取消阶段恢复资源状态。
适用于需要灵活控制事务执行过程的场景。
- RocketMQ：支持将消息发送和数据库操作绑定在同一个事务中，确保消息的可靠传递和事务的原子性。
适用于需要高可靠性和一致性保证的消息传递场景。
- TCC-Transaction：将事务处理分为Try、Confirm和Cancel三个阶段。
提供高性能和简单易用的分布式事务服务。
适用于需要灵活控制事务执行过程的微服务架构场景。
- Atomikos：支持Java Transaction API（JTA），允许应用程序使用标准的JTA接口进行事务管理。
提供了XA协议的实现，允许应用程序参与到分布式事务中。
可以与关系型数据库、消息队列等资源进行分布式事务处理。
- LCN：LCN框架主要是为微服务框架提供分布式事务的支持，在微服务框架上做了进一步的事务机制优化。
- Myth：支持Dubbo、Spring Cloud、Motan等RPC框架进行分布式事务。
通过消息队列来实现事务的提交和回滚，确保数据的一致性。
- Hmily：支持Dubbo、Spring Cloud、Motan等RPC框架进行分布式事务。
提供了TCC模式的事务处理机制，确保事务的原子性和一致性。

- MySQL XA事务: 另外需要说到的一点是，MySQL本身是支持二阶段提交的XA事务，
